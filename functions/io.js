/**
 * database io funcs
 * treat this file like a mini library - import these functions
 * to be used wherever they are needed
 *
 * !!!!!!!!!!
 * REMEMBER TO CHANGE SECURITY SETTINGS AFTER TESTING AND AUTH IS SET UP
 * 
 * reminder to add catches to errors (no data, offline, etc)
 */

import firebase from "firebase/app";
import db from "../firebase/config";

import * as ImagePicker from "expo-image-picker";

// returns image in form of blob (able to be stored by firebase)
// figure out a way to have event listeners to make sure the picture is actually
// taken when uploaded, since this is an async func
let imagePickerMediaLibrary = async ({ allowsEditing, aspect }) => {
  let permissionResult =
    await ImagePicker.requestMediaLibraryPermissionsAsync();

  if (permissionResult.granted === false) {
    alert("Permission to access media library is required");
    return;
  }

  let pickerResult = await ImagePicker.launchImageLibraryAsync({
    allowsEditing: allowsEditing,
    aspect: aspect,
  });

  return pickerResult;
};

let imagePickerCamera = async ({ allowsEditing, aspect }) => {
  let permissionResult = await ImagePicker.requestCameraPermissionsAsync();

  if (permissionResult.granted === false) {
    alert("Permission to access camera is required");
    return;
  }

  let pickerResult = await ImagePicker.launchCameraAsync({
    allowsEditing: allowsEditing,
    aspect: aspect,
  });

  return pickerResult;
};

// pic is the image object (generated from imagePickerMediaLibrary or imagePickerCamera)
let storeUserProfilePic = async (userID, pic) => {
  const picuri = await fetch(pic.uri);
  const blob = await picuri.blob();
  firebase
    .storage()
    .ref()
    .child("users/" + userID + "/profilepic.jpg")
    .put(blob);
};

// tested - returns download url (not sure how it is used with expo)
let retrieveUserProfilePic = async (userID) => {
  const url = await firebase.storage()
    .ref()
    .child('users/' + userID + "/profilepic.jpg")
    .getDownloadURL();
  return url;
};

let storePostPic = async (postID, pic) => {
  const picuri = await fetch(pic.uri);
  const blob = await picuri.blob();
  firebase
    .storage()
    .ref()
    .child("posts/" + postID + "/postpic.jpg")
    .put(blob);
}

// tested - returns download url (not sure how it is used with expo)
let retrievePostPic = async (postID) => {
  const url = await firebase.storage()
    .ref()
    .child('posts/' + postID + "/postpic.jpg")
    .getDownloadURL();
  return url;
};

// stores new user data
function storeUserData(userID, firstname, lastname) {
  firebase
    .database()
    .ref("users/" + userID)
    .set({
      firstname: firstname,
      lastname: lastname,
    });
}

// retreiving data once
// use JSON.parse to parse data before return
let getUserData = async (userID) => {
  // sets up path
  const db = firebase.database().ref();
  const snapshot = await db.child("users")
    .child(userID)
    .get();
  return snapshot.val();
}

// stores post data - tested
function storePostData(userID, postTitle, postDescription, postCreationDate, postCategories) {
  firebase.firestore().collection("post").add({
    uid: userID,
    title: postTitle,
    description: postDescription,
    date: postCreationDate,
    categories: postCategories
  }).then((docRef) => {
    /**
     * slightly confusing - 
     * all data in rtdb has to be stored in key-value pairs
     * so storing an array ['a', 'b'] would be {0: 'a', 1: 'b'} in the db
     * 
     * all user posts are stored in key-value pairs {userPostID: postID}
     * where postID is the actual postID found in firestore/posts
     * and userPostID is a unique ID for the user generated by push(), and its only use
     * is to store the postID in a key-value pair
     * 
     * working on a better solution, but this works for now
     */
    firebase.database().ref("users/" + userID +"/userPosts")
    .push(docRef.id);
    firebase.firestore.collection("post").doc(docRef.id).set({
      postId : docRef.id;
    });
    return docRef.id;
  });
}

let getPostData = async (postID) => {
  const snapshot = await firebase
    .firestore()
    .collection("post")
    .doc(postID)
    .get();
  return snapshot.data();
}

// gets all posts from category - pass in a string
// returns array of post objects
let getPostFromCategory = async (category) => {
  var categoryPosts = [];
  await firebase
  .firestore()
  .collection("post")
  .where("tags", "array-contains", category)
  .get()
  .then((querySnapshot) => {
    querySnapshot.forEach((doc) => {
      categoryPosts.push(doc.data());
    });
  });
  return categoryPosts;
}

// gets all posts posted from a user - pass in userID as a string
// returns array of post objects
let getPostFromUser = async (userID) => {
  var userPosts = [];
  await firebase
  .firestore()
  .collection("post")
  .where("userId", "==", userID)
  .get()
  .then((querySnapshot) => {
    querySnapshot.forEach((doc) => {
      userPosts.push(doc.data());
    });
  });
  return userPosts;
}

// gets all posts - probably shouldn't be used
let getAllPosts = async () => {
  var posts = [];
  await firebase
  .firestore()
  .collection("post")
  .get()
  .then((allPosts) => {
    allPosts.forEach((doc) => {
      posts.push(doc.data());
    });
  });
  return posts;
}

// get the latest post - input the number of posts you want
let getLatestPost = async (num) => {
  var posts = [];
  await firebase
  .firestore()
  .collection("post")
  .orderBy("date", "desc")
  .limit(num)
  .get()
  .then((newPosts) => {
    newPosts.forEach((doc) => {
      posts.push(doc.data());
    });
  });
  return posts;
}

// lets a user save a post
let storeUserSavedPost = async (uid, postID) => {
  // same as before - check storePostData
  firebase.database().ref("users/" + uid +"/savedPosts")
  .push(postID);
}

// gets a user's saved posts
let getUserSavedPosts = async (userId) => {
  if (userId == null) {
    return null;
  }

  const user = await getUserData(userId);

  if (user == null || user.savedPosts == null) {
    return [];
  }

  // first create an array of postIds
  let postIds = [];
  for (const [key, postId] of Object.entries(user.savedPosts)) {
    postIds.unshift(postId);
  }

  // then return user's saved posts
  const savedPosts = await Promise.all(
    postIds.map((postId) => getPostData(postId))
  ).catch((error) => {
    return null;
  });

  return savedPosts;
}

export {
  // image funcs
  imagePickerMediaLibrary,
  imagePickerCamera,
  storeUserProfilePic,
  storePostPic,
  retrieveUserProfilePic,
  retrievePostPic,

  // user db funcs
  storeUserData,
  getUserData,
  storeUserSavedPost,
  getUserSavedPosts,

  // post db funcs
  storePostData,
  getPostData,
  getPostFromCategory,
  getPostFromUser,
  getAllPosts,
  getLatestPost
};

/**
 * how the data is structured:
 * 
 * user data (rtdb):
 * users/
 *  -> uid (auto gen)
 *    -> firstname
 *    -> lastname
 *    -> profile pic
 *    -> grad year
 *    -> posts
 *      -> postid (auto gen)
 *    -> saved posts
 *      -> postid
 * 
 * post (firestore)
 * posts/
 *  -> postid
 *    -> uid
 *    -> title
 *    -> description
 *    -> image
 *    -> [categories]
 *    -> creation date
 */

